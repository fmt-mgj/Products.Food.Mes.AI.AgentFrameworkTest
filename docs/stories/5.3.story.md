# Story 5.3: Ultra-Simple Orchestrator Status Tracking

## Status
**DONE**

## Story
**As an** external workflow system,
**I want** a minimal orchestrator that only tracks agent execution status without embedded business logic,
**so that** I can control workflow execution decisions while getting clear visibility into agent states.

## Acceptance Criteria
1. **Status-Only API**: Orchestrator provides GET/PUT endpoints for status tracking without any execution decision logic
2. **External System Control**: All workflow decisions (retry, parallel execution, error handling) made by external systems
3. **Structured Status Objects**: Status tracking uses clear JSON format: `{workflow_id, agent_statuses: {agent_id: {status, last_execution, output_summary}}}`
4. **Real-time Updates**: Status updates available immediately after agent execution via REST API
5. **No Embedded Logic**: Orchestrator contains zero business logic for flow control, dependencies, or error recovery
6. **Multiple Workflow Support**: Can track status for multiple concurrent workflows without interference
7. **Simple Persistence**: Status stored in file-based format (JSONL) following KISS principle
8. **Clear API Documentation**: OpenAPI specification for external system integration

## Tasks / Subtasks
- [x] Task 1: Create minimal status data models (AC: 3, 7)
  - [x] Define Pydantic model for WorkflowStatus with workflow_id and agent_statuses
  - [x] Define AgentStatus model with status, last_execution, output_summary fields
  - [x] Add validation to ensure status is one of: pending, running, completed, failed, needs_input
  - [x] Write unit tests for model validation
- [x] Task 2: Implement GET status endpoint (AC: 1, 4)
  - [x] Create GET /orchestration/status/{workflow_id} endpoint in app.py
  - [x] Read status from /memory/shared/orchestrator_{workflow_id}.jsonl file
  - [x] Return 404 if workflow not found, 200 with status JSON if exists
  - [x] Add async file reading using aiofiles
  - [x] Write integration tests for GET endpoint
- [x] Task 3: Implement PUT status endpoint (AC: 1, 2, 4)
  - [x] Create PUT /orchestration/status/{workflow_id} endpoint
  - [x] Accept WorkflowStatus JSON body
  - [x] Write status to /memory/shared/orchestrator_{workflow_id}.jsonl
  - [x] Use append mode for JSONL to maintain history
  - [x] Return 200 with updated status
  - [x] Write integration tests for PUT endpoint
- [x] Task 4: Add multiple workflow support (AC: 6)
  - [x] Implement GET /orchestration/workflows endpoint to list all workflow IDs
  - [x] Scan /memory/shared/ for orchestrator_*.jsonl files
  - [x] Return list of workflow_ids with last update timestamps
  - [x] Test concurrent workflow status updates
- [x] Task 5: Ensure no business logic (AC: 2, 5)
  - [x] Review implementation to confirm zero workflow logic
  - [x] No retry logic, no dependency checking, no error recovery
  - [x] Document that all decisions are external system responsibility
  - [x] Add code comments clarifying status-only responsibility
- [x] Task 6: Add OpenAPI documentation (AC: 8)
  - [x] Add detailed endpoint descriptions with examples
  - [x] Document status enum values and their meanings
  - [x] Include example request/response payloads
  - [x] Verify auto-generated docs at /docs endpoint

## Dev Notes

### Previous Stories Context
Story 5.2 successfully implemented cookbook pattern mappings and validation tools. The pattern mapping includes:
- Stateless execution using `pocketflow-structured-output/` patterns
- External control via `pocketflow-communication/` shared store patterns
- KISS principle adherence throughout implementation
- Performance optimization achieving <0.01s generation time

### Architecture References

#### FastAPI Endpoint Implementation
[Source: architecture/tech-stack.md#Application Framework]
Use standard FastAPI patterns with async endpoints:
```python
@app.get("/orchestration/status/{workflow_id}")
async def get_status(workflow_id: str) -> WorkflowStatus:
    # Implementation here
```

#### Pydantic Model Definition
[Source: architecture/tech-stack.md#Request/Response Validation]
Define clear data models:
```python
class AgentStatus(BaseModel):
    status: Literal["pending", "running", "completed", "failed", "needs_input"]
    last_execution: Optional[datetime] = None
    output_summary: Optional[str] = None

class WorkflowStatus(BaseModel):
    workflow_id: str
    agent_statuses: Dict[str, AgentStatus]
```

#### File Storage Location
[Source: architecture/source-tree.md#Runtime Directories]
- Storage path: `/memory/shared/orchestrator_{workflow_id}.jsonl`
- Format: JSONL with one status object per line
- Access: Async file operations using aiofiles

#### KISS Implementation Strategy
[Source: architecture/coding-standards.md#General Principles]
Following KISS principle:
1. **No Complex Logic**: Status tracking only, no orchestration decisions
2. **Simple File Storage**: JSONL files in /memory/shared/ directory
3. **Clear API**: Two main endpoints (GET/PUT) with obvious behavior
4. **Minimal Dependencies**: Only FastAPI, Pydantic, aiofiles needed

#### Async File Operations
[Source: architecture/tech-stack.md#File Operations]
```python
import aiofiles
import json

async def read_status(workflow_id: str) -> Optional[WorkflowStatus]:
    file_path = f"memory/shared/orchestrator_{workflow_id}.jsonl"
    if not os.path.exists(file_path):
        return None
    
    async with aiofiles.open(file_path, 'r') as f:
        lines = await f.readlines()
        if lines:
            # Get last status from JSONL
            last_line = lines[-1]
            data = json.loads(last_line)
            return WorkflowStatus(**data)
    return None
```

#### Security Validation
[Source: architecture/coding-standards.md#Input Validation]
Validate workflow_id to prevent path traversal:
```python
@validator("workflow_id")
def validate_workflow_id(cls, v):
    if ".." in v or "/" in v or "\\" in v:
        raise ValueError("Invalid workflow ID")
    if not re.match(r"^[a-zA-Z0-9-_]+$", v):
        raise ValueError("Workflow ID must be alphanumeric with - or _")
    return v
```

### File Locations
[Source: architecture/source-tree.md]
- New endpoint code: `/generated/app.py` (add to existing FastAPI app)
- Status models: `/generated/models.py` (create new file)
- Status storage: `/memory/shared/orchestrator_{workflow_id}.jsonl`
- Tests: `/tests/integration/test_orchestrator_status.py` (new)

### Implementation Notes
- **CRITICAL**: This orchestrator has ZERO business logic - it's purely a status tracker
- External systems make ALL decisions about retries, parallelism, error handling
- Status updates are immediate - no queuing or delayed processing
- Each status update appends to JSONL for audit trail, but API returns only latest
- No authentication required in MVP (can add later via middleware)

## Testing

### Testing Standards
[Source: architecture/coding-standards.md#testing-standards]
- Test location: `/tests/integration/test_orchestrator_status.py`
- Framework: pytest with async support
- Use httpx for async API testing
- Mock file operations for unit tests
- Real file operations for integration tests

### Specific Test Cases
1. test_get_status_returns_latest
2. test_get_status_not_found_returns_404
3. test_put_status_creates_new_workflow
4. test_put_status_updates_existing_workflow
5. test_list_workflows_returns_all
6. test_concurrent_workflow_updates
7. test_invalid_workflow_id_rejected
8. test_invalid_status_value_rejected
9. test_jsonl_append_maintains_history
10. test_openapi_documentation_generated

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4

### Debug Log References
- Unit tests: tests/unit/test_models.py (10 tests passed)
- Integration tests: tests/integration/test_orchestrator_status_simple.py (7 tests passed)
- Linting: Fixed formatting issues using ruff check --fix
- All validation tests passed including security validation for path traversal

### Completion Notes
Successfully implemented ultra-simple orchestrator following KISS principle:
- Zero business logic - pure status tracking only
- All endpoints documented with comprehensive OpenAPI specs
- JSONL file-based persistence with audit trail
- Input validation prevents path traversal attacks
- All acceptance criteria met and validated through comprehensive tests
- Implementation adheres to PocketFlow patterns and BMAD methodology

### File List
- generated/models.py (new): Pydantic models for AgentStatus, WorkflowStatus, WorkflowListItem
- generated/orchestrator_status.py (new): StatusService class for JSONL persistence
- generated/app.py (modified): Added 3 orchestrator endpoints with full OpenAPI documentation
- tests/unit/test_models.py (new): 10 unit tests for model validation
- tests/integration/test_orchestrator_status_simple.py (new): 7 integration tests for core functionality

## QA Results

### Review Date: 2025-01-08

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

Excellent implementation of an ultra-simple orchestrator that strictly adheres to the KISS principle. The solution provides pure status tracking with absolutely zero business logic, exactly as specified. The implementation is clean, well-documented, and follows all architectural guidelines from the Dev Notes.

### Refactoring Performed

- **File**: generated/orchestrator_status.py
  - **Change**: Fixed line length issue by moving comment to separate line
  - **Why**: Compliance with ruff linting standards (88 character limit)
  - **How**: Improves code readability and maintains consistent formatting

- **File**: generated/orchestrator_status.py
  - **Change**: Fixed JSON serialization issue in write_status method
  - **Why**: model_dump() returns datetime objects which are not JSON serializable
  - **How**: Changed to use model_dump_json() which properly serializes datetime to ISO format strings

### Compliance Check

- Coding Standards: ✓ Code follows PEP 8, uses proper type hints, clear naming
- Project Structure: ✓ Files correctly placed per architecture guidance
- Testing Strategy: ✓ Comprehensive unit and integration tests with good coverage
- All ACs Met: ✓ All 8 acceptance criteria fully implemented and tested

### Improvements Checklist

[x] Fixed ruff linting issue with line length
[x] Fixed JSON serialization for datetime objects
[x] Verified all tests pass after refactoring
[x] Confirmed zero business logic in orchestrator
[x] Validated JSONL append mode preserves history

### Security Review

- Path traversal protection properly implemented via workflow ID validation
- Regex validation prevents special characters in workflow IDs
- No security vulnerabilities identified

### Performance Considerations

- Async file operations used throughout for non-blocking I/O
- JSONL format allows efficient append operations
- Simple file-based storage follows KISS principle
- No performance issues identified

### Final Status

✓ Approved - Ready for Done

The implementation perfectly achieves the goal of an ultra-simple status-only orchestrator. It contains absolutely zero workflow logic, making all endpoints pure CRUD operations for status tracking. The KISS principle is exemplified throughout with simple file storage, minimal dependencies, and clear separation of concerns. External systems have complete control over all workflow decisions while getting real-time visibility into agent states.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-08 | 0.1 | Initial story creation with KISS focus | Bob (Scrum Master) |