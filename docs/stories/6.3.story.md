# Story 6.3: Workflow Lifecycle Management

## Status
**Done**

## Story
**As an** external workflow engine,
**I want** to initialize, reset, and clean up workflow states through simple API endpoints,
**so that** I can manage the complete lifecycle of workflows without manual file manipulation.

## Acceptance Criteria
1. **POST /orchestration/workflow/{workflow_id}/init**: Initialize new workflow with story_id and optional initial agent states
2. **DELETE /orchestration/workflow/{workflow_id}**: Complete workflow cleanup removing all associated data (status, history, memory)
3. **POST /orchestration/workflow/{workflow_id}/reset**: Reset workflow to initial state while preserving history for audit
4. **GET /orchestration/workflows**: List all active workflows with basic metadata (workflow_id, story_id, created_at, status)
5. **Automatic Cleanup**: Support configurable retention period for automatic cleanup of completed workflows (default: 7 days)
6. **Idempotent Operations**: All lifecycle operations must be idempotent - safe to call multiple times
7. **History Preservation**: Reset operations append to history, never delete historical records
8. **KISS Implementation**: Simple file operations, no complex state machines or business logic

## Tasks / Subtasks
- [x] Task 1: Create workflow initialization endpoint (AC: 1, 6)
  - [x] Implement POST /orchestration/workflow/{workflow_id}/init endpoint
  - [x] Accept InitWorkflowRequest with story_id and optional initial_agents
  - [x] Create initial status file with "initialized" state
  - [x] Ensure idempotent - return existing if already initialized
  - [x] Write integration tests for initialization scenarios
- [x] Task 2: Implement workflow deletion endpoint (AC: 2, 6)
  - [x] Create DELETE /orchestration/workflow/{workflow_id} endpoint
  - [x] Remove status file from memory/shared/
  - [x] Remove history files from memory/history/
  - [x] Remove any isolated memory files for this workflow
  - [x] Make operation idempotent - success even if already deleted
  - [x] Write integration tests for deletion
- [x] Task 3: Add workflow reset functionality (AC: 3, 7)
  - [x] Implement POST /orchestration/workflow/{workflow_id}/reset endpoint
  - [x] Append reset event to history before clearing status
  - [x] Reset status to initial state with all agents "pending"
  - [x] Preserve story_id from original initialization
  - [x] Write integration tests for reset scenarios
- [x] Task 4: Create workflow listing endpoint (AC: 4)
  - [x] Implement GET /orchestration/workflows endpoint
  - [x] Read orchestrator_index.jsonl for active workflows
  - [x] Return list with workflow_id, story_id, created_at, last_updated
  - [x] Support optional query params: story_id filter, date range
  - [x] Add pagination support (limit/offset)
  - [x] Write integration tests
- [x] Task 5: Implement automatic cleanup mechanism (AC: 5)
  - [x] Add retention_days config to runtime.yaml (default: 7)
  - [x] Create cleanup_service.py with scan_and_cleanup method
  - [x] Check workflow completion time against retention policy
  - [x] Only cleanup workflows in terminal states (completed/failed)
  - [x] Add startup hook to run cleanup on app initialization
  - [x] Write unit/integration tests for cleanup logic
- [x] Task 6: Ensure KISS compliance (AC: 8)
  - [x] Review all code for unnecessary complexity
  - [x] Verify no business logic embedded in lifecycle operations
  - [x] Document that external systems own workflow orchestration
  - [x] Add code comments emphasizing simplicity

## Dev Notes

### Previous Story Context
- **Story 6.1**: Implemented status-only orchestration API with GET/PUT /orchestration/status endpoints
- **Story 6.2**: Added agent execution history and audit trail with append-only JSONL storage
- Both stories emphasize ZERO business logic in orchestrator - external systems make all decisions
- Status tracking uses WorkflowStatus model with workflow_id, story_id, and agent_statuses
- History tracking uses HistoryEntry model with append-only storage in memory/history/

### Architecture References

#### Data Model Extensions
[Source: architecture/tech-stack.md#Data Management]
Extend existing models with initialization request:
```python
from pydantic import BaseModel, Field
from typing import Optional, Dict, List
from datetime import datetime

class InitWorkflowRequest(BaseModel):
    story_id: str = Field(..., pattern="^[a-zA-Z0-9-_.]+$")
    initial_agents: Optional[List[str]] = None  # Agent IDs to initialize
    metadata: Optional[Dict[str, str]] = None  # Optional metadata

class WorkflowListItem(BaseModel):
    workflow_id: str
    story_id: str
    created_at: datetime
    updated_at: datetime
    status_summary: str  # "initialized", "in_progress", "completed", "failed"
    agent_count: int
```

#### File Storage Structure
[Source: architecture/source-tree.md#Runtime Directories]
Lifecycle operations affect these locations:
```
memory/
├── shared/
│   ├── orchestrator_{workflow_id}.jsonl    # Status file (remove on delete)
│   └── orchestrator_index.jsonl            # Index of all workflows
├── history/
│   ├── {workflow_id}_history.jsonl         # History (remove on delete)
│   └── agent_index/
│       └── {agent_id}_workflows.jsonl      # Update on delete
└── isolated/
    └── {agent}_{story}.jsonl               # Agent memory (remove on delete)
```

#### FastAPI Endpoint Patterns
[Source: architecture/coding-standards.md#Code Style Guide]
Follow existing patterns from Stories 6.1 and 6.2:
```python
@app.post("/orchestration/workflow/{workflow_id}/init")
async def init_workflow(
    workflow_id: str,
    request: InitWorkflowRequest
) -> WorkflowStatus:
    """Initialize a new workflow with given story_id."""
    # Simple file creation, no business logic

@app.delete("/orchestration/workflow/{workflow_id}")
async def delete_workflow(workflow_id: str) -> Dict[str, str]:
    """Remove all data associated with a workflow."""
    # File cleanup only, idempotent operation
```

#### KISS Implementation Guidelines
[Source: CLAUDE.md#CRITICAL Project Boundaries]
- NO business logic in orchestrator - only storage operations
- Use simple file operations with aiofiles
- All operations must be idempotent
- No complex state machines or workflow engines
- External systems own all orchestration decisions

### File Locations
[Source: architecture/source-tree.md]
- Models: `/generated/models.py` (add InitWorkflowRequest, WorkflowListItem)
- Service: `/generated/lifecycle_service.py` (new file)
- Cleanup: `/generated/cleanup_service.py` (new file)  
- Endpoints: `/generated/app.py` (add lifecycle endpoints)
- Tests: `/tests/integration/test_orchestrator_lifecycle.py` (new file)

### Implementation Notes
- **CRITICAL**: Maintain ZERO business logic principle from Epic 6
- All operations are simple CRUD on files
- Idempotency ensures operations can be retried safely
- Cleanup is configurable but has sensible defaults
- History is NEVER deleted except through explicit DELETE operation
- Use existing StatusService and HistoryService where possible
- Follow async patterns with proper error handling
- Validate workflow_id format to prevent path traversal

### Testing Standards
[Source: architecture/coding-standards.md#Testing Standards]
- Test location: `/tests/integration/test_orchestrator_lifecycle.py`
- Framework: pytest with async support (pytest-asyncio)
- Use httpx AsyncClient for API testing
- Follow AAA pattern (Arrange, Act, Assert)
- Mock file I/O for unit tests using aiofiles mocks
- Test idempotency by calling operations multiple times
- Verify file cleanup with temporary directories

### Specific Test Cases
1. test_init_workflow_creates_files
2. test_init_workflow_is_idempotent  
3. test_delete_workflow_removes_all_files
4. test_delete_nonexistent_workflow_succeeds
5. test_reset_workflow_preserves_history
6. test_reset_workflow_clears_agent_states
7. test_list_workflows_returns_all_active
8. test_list_workflows_with_filters
9. test_automatic_cleanup_removes_old_workflows
10. test_cleanup_preserves_recent_workflows
11. test_cleanup_only_affects_terminal_states
12. test_all_operations_are_idempotent

## Testing

Test implementation will follow the patterns established in stories 6.1 and 6.2, using pytest with async support and focusing on file operation verification rather than business logic testing.

## Dev Agent Record

### Agent Model Used
GPT-5 (Cursor, James/dev persona)

### Debug Log References
- New tests: `tests/integration/test_orchestrator_lifecycle.py`
- Existing tests exercised: `tests/integration/test_orchestrator_status.py::TestGetWorkflowsActiveEndpoint`
- Startup cleanup loads `config/runtime.yaml` key `orchestrator.retention_days`

### Completion Notes
- Implemented idempotent lifecycle endpoints: init, reset, delete
- Enhanced workflow listing with metadata, filters, and pagination
- Added automatic cleanup service with startup hook and manual trigger
- Preserved zero-business-logic boundary; pure file CRUD with aiofiles
- Added comprehensive integration tests for new functionality

### File List
- Modified: `generated/models.py`
- Modified: `generated/orchestrator_status.py`
- Modified: `generated/app.py`
- Added: `generated/lifecycle_service.py`
- Added: `generated/cleanup_service.py`
- Added: `tests/integration/test_orchestrator_lifecycle.py`
- Modified: `config/runtime.yaml`

## QA Results

### Review Date: 2025-08-08

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

Excellent implementation following KISS principles and maintaining zero-business-logic boundary. The code is clean, straightforward, and properly adheres to the BMAD and PocketFlow framework guidelines. All acceptance criteria are implemented correctly with proper idempotency and file-based operations.

### Refactoring Performed

No refactoring needed. The implementation is already optimal for its purpose:
- Simple file operations using aiofiles
- Proper idempotency in all lifecycle operations
- Clean separation of concerns between services
- No unnecessary complexity or business logic

### Compliance Check

- Coding Standards: ✓ Following established patterns from stories 6.1 and 6.2
- Project Structure: ✓ Files correctly placed in generated/ directory
- Testing Strategy: ✓ Comprehensive integration tests with proper async support
- All ACs Met: ✓ All 8 acceptance criteria fully implemented
- KISS Principle: ✓ Exceptionally well followed - pure CRUD operations only

### Improvements Checklist

All implementation is clean and complete. Minor suggestion for future consideration:

- [x] Idempotent operations properly implemented
- [x] History preservation on reset operations
- [x] Automatic cleanup with configurable retention
- [x] Proper error handling and async patterns
- [ ] Consider migrating from deprecated @app.on_event to lifespan handlers (non-critical)

### Security Review

No security concerns. Proper validation of workflow_id format prevents path traversal attacks. No sensitive data exposed or logged.

### Performance Considerations

Implementation is efficient with:
- Async file operations throughout
- Reasonable limits on listing endpoints (max 1000)
- Non-blocking cleanup on startup
- Simple file-based storage appropriate for the use case

### Final Status

✓ **Approved - Ready for Done**

Exceptional implementation maintaining strict adherence to KISS principles and zero-business-logic boundary. All tests pass successfully.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-08 | 0.2 | Implemented lifecycle endpoints (init/reset/delete), listing enhancements, cleanup service, and tests | James (Dev Agent) |
| 2025-08-08 | 0.1 | Initial story creation extending Epic 6 orchestrator capabilities | Bob (Scrum Master) |