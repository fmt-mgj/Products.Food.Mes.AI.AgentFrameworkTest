# Story 1.4: Jinja Template Engine and Code Generation

## Status
**DONE** ✅

## Story
**As a** developer,
**I want** to render Python code from Jinja templates using parsed BMAD metadata,
**so that** I can generate executable PocketFlow agents and FastAPI application code.

## Acceptance Criteria
1. Jinja templates created for agents/*.py and app.py in appropriate template directory
2. Template renderer accepts agent metadata and generates valid Python code
3. Generated code includes proper imports, class definitions, and PocketFlow decorators
4. Tool references from tools.yaml converted to @utool decorated functions
5. All generated code written to /generated directory preserving structure
6. Generated code passes black and ruff formatting without errors
7. Template rendering completes for typical project in under 500ms

## Tasks / Subtasks
- [x] **DONE** Task 1: Set up Jinja template infrastructure (AC: 1)
  - [x] **DONE** Create scripts/templates/ directory
  - [x] **DONE** Create agent.py.j2 template for PocketFlow nodes
  - [x] **DONE** Create app.py.j2 template for FastAPI application
  - [x] **DONE** Add scripts/generator.py module
- [x] **DONE** Task 2: Create simple agent template (AC: 2, 3)
  - [x] **DONE** Template PocketFlow Node class structure
  - [x] **DONE** Include prep/exec/post methods based on BMAD prompt
  - [x] **DONE** Add proper imports (from pocketflow import Node)
  - [x] **DONE** Map agent id to class name (e.g., analyst → AnalystNode)
- [x] **DONE** Task 3: Create minimal FastAPI app template (AC: 2, 3)
  - [x] **DONE** Template basic FastAPI application structure
  - [x] **DONE** Include /run endpoint that executes flow
  - [x] **DONE** Add health check endpoint
  - [x] **DONE** Import generated agent nodes
- [x] **DONE** Task 4: Implement template renderer (AC: 2, 5)
  - [x] **DONE** Load Jinja templates from scripts/templates/
  - [x] **DONE** Render templates with agent metadata
  - [x] **DONE** Write generated files to /generated directory
  - [x] **DONE** Preserve directory structure (agents/, app.py)
- [x] **DONE** Task 5: Add code formatting (AC: 6)
  - [x] **DONE** Run black on generated code
  - [x] **DONE** Run ruff for linting
  - [x] **DONE** Log any formatting issues
- [x] **DONE** Task 6: Create unit tests (AC: 7)
  - [x] **DONE** Test template rendering with sample metadata
  - [x] **DONE** Test file generation and directory structure
  - [x] **DONE** Test formatting compliance
  - [x] **DONE** Measure rendering performance

## Dev Notes

### Previous Story Context
- Story 1.2: Parser provides AgentMetadata objects
- Story 1.3: Config loader provides workflow and tools configuration
These will be combined and passed to the generator for template rendering.

### PocketFlow Integration (KISS Approach)
[Source: pocketflow/__init__.py, cookbook examples]

Keep templates SIMPLE - just map BMAD agents to basic PocketFlow nodes:
```python
# Simple node structure from cookbook
class AgentNameNode(Node):
    def prep(self, shared):
        # Get input from shared store
        return shared.get("input", "")
    
    def exec(self, prep_res):
        # Execute agent prompt with LLM
        prompt = "BMAD prompt content here"
        return call_llm(prompt + prep_res)
    
    def post(self, shared, prep_res, exec_res):
        # Store result and return action
        shared["result"] = exec_res
        return "default"
```

### Template File Structure
```
scripts/
├── generator.py              # THIS STORY - main generator
├── templates/               # THIS STORY - Jinja templates
│   ├── agent.py.j2         # Template for agent nodes
│   └── app.py.j2           # Template for FastAPI app
```

### Simple Agent Template (agent.py.j2)
```jinja
from pocketflow import Node
from utils import call_llm

class {{ agent.id|capitalize }}Node(Node):
    """{{ agent.description }}"""
    
    def prep(self, shared):
        return shared.get("input", "")
    
    def exec(self, prep_res):
        prompt = """{{ agent.prompt_content }}"""
        return call_llm(prompt + "\n" + prep_res)
    
    def post(self, shared, prep_res, exec_res):
        shared["{{ agent.id }}_result"] = exec_res
        return "default"
```

### Simple App Template (app.py.j2)
```jinja
from fastapi import FastAPI
from pocketflow import Flow
{% for agent in agents %}
from agents.{{ agent.id }} import {{ agent.id|capitalize }}Node
{% endfor %}

app = FastAPI(title="BMAD PocketFlow Runtime")

@app.get("/health")
def health():
    return {"status": "ok"}

@app.post("/run")
def run_flow(input: str):
    # Create simple sequential flow
    flow = Flow()
    shared = {"input": input}
    
    {% for agent in workflow_sequence %}
    # Run {{ agent }} agent
    node = {{ agent|capitalize }}Node()
    node.run(shared)
    {% endfor %}
    
    return {"result": shared.get("result", "")}
```

### KISS Implementation Guidelines
- Don't over-engineer templates - keep them minimal
- Start with sequential flow only (no branching yet)
- Use simple shared store for communication
- No complex error handling in templates
- Focus on generating working code, not perfect code

### Dependencies
[Source: Story 1.1 - already installed]
- jinja2>=3.1.0 (template engine)
- black>=23.12.0 (formatter)
- ruff>=0.1.8 (linter)

### Testing
- Place tests in `tests/unit/test_generator.py`
- Use sample AgentMetadata objects for testing
- Verify generated code syntax with ast.parse()
- Check formatting with black --check

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 0.1 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References
- Unit tests: 16/16 passing (tests/unit/test_generator.py)
- Integration test: PASSED (scripts/test_integration.py)
- Generation time: <500ms requirement met
- Code formatting: Black and ruff both pass successfully

### Completion Notes List
1. **Template Infrastructure**: Created complete Jinja2 template system in scripts/templates/
2. **PocketFlow Integration**: Templates follow exact cookbook patterns from pocketflow-fastapi examples
3. **Code Generation**: Implemented robust Generator class with error handling and formatting
4. **Testing**: Comprehensive test suite covering all functionality and performance requirements
5. **KISS Principle**: Kept templates minimal and straightforward per story requirements

### File List
**Created:**
- `scripts/generator.py` - Main template renderer with Generator class
- `scripts/templates/agent.py.j2` - PocketFlow Node template
- `scripts/templates/app.py.j2` - FastAPI application template  
- `scripts/templates/utils.py.j2` - Utility functions template
- `scripts/templates/agents_init.py.j2` - Package initialization template
- `tests/unit/test_generator.py` - Comprehensive unit tests (16 test cases)
- `scripts/test_integration.py` - End-to-end integration test
- `bmad/agents/analyst.md` - Sample BMAD agent for testing
- `bmad/agents/summarizer.md` - Sample BMAD agent for testing

**Generated (in /generated directory):**
- `agents/analyst.py` - Generated PocketFlow node
- `agents/summarizer.py` - Generated PocketFlow node  
- `agents/__init__.py` - Generated package init
- `app.py` - Generated FastAPI application
- `utils.py` - Generated utility functions

## QA Results

### Review Date: 2025-08-06

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

**✅ EXCELLENT IMPLEMENTATION** - This story demonstrates outstanding adherence to KISS principles and PocketFlow framework patterns. The implementation is clean, minimal, and precisely follows the cookbook patterns from `pocketflow-fastapi-*` examples.

**Key Strengths:**
- Perfect alignment with PocketFlow's 100-line framework architecture
- Clean separation of concerns with proper prep/exec/post lifecycle
- Minimal template complexity following BMAD → PocketFlow conversion principles
- Excellent test coverage (16/16 tests passing) with performance validation
- Generation completes in <500ms requirement easily met (0.26s for full test suite)

### Refactoring Performed

None required - implementation follows best practices correctly.

### Compliance Check

- **Coding Standards**: ✅ Follows PocketFlow patterns perfectly
- **Project Structure**: ✅ Correct template organization in `scripts/templates/`
- **Testing Strategy**: ✅ Comprehensive unit tests with 100% coverage
- **All ACs Met**: ✅ All acceptance criteria implemented and verified
- **KISS Principle**: ✅ Templates are minimal and straightforward
- **PocketFlow Integration**: ✅ Proper Node lifecycle and Flow orchestration

### Improvements Checklist

**All items completed and verified:**

- [x] ✅ Jinja template infrastructure established (`scripts/templates/`)
- [x] ✅ Agent template renders proper PocketFlow Node structure
- [x] ✅ FastAPI app template with sequential flow execution  
- [x] ✅ Template renderer with file generation to `/generated`
- [x] ✅ Black and ruff formatting integration
- [x] ✅ Performance requirement met (<500ms generation)
- [x] ✅ Comprehensive test suite with AST validation
- [x] ✅ Proper imports and class name generation
- [x] ✅ Utils template with OpenAI LLM integration
- [x] ✅ Agents package initialization template

### Security Review

✅ **No security concerns** - Templates generate safe Python code with proper environment variable handling for API keys. No hardcoded secrets or injection vulnerabilities.

### Performance Considerations

✅ **Exceeds performance requirements** - Generation completes well under 500ms requirement. Test suite demonstrates generation of 5 agents + infrastructure in <260ms.

### Architecture Review

✅ **Perfect PocketFlow alignment** - Implementation demonstrates deep understanding of:
- PocketFlow's minimal Node lifecycle (prep → exec → post)
- Proper shared store communication patterns
- Sequential flow orchestration using `>>` chaining
- Template simplicity following cookbook examples

### Technical Excellence Notes

1. **Template Design**: Clean Jinja2 templates with proper escaping and filters
2. **Error Handling**: Robust GenerationError handling throughout
3. **Code Generation**: AST-validated output ensures syntactic correctness  
4. **Testing**: Performance, syntax, import, and integration testing
5. **BMAD Integration**: Proper metadata mapping to PocketFlow structures

### Final Status

**✅ Approved - Ready for Done**

This implementation represents exemplary work that perfectly balances the BMAD methodology requirements with PocketFlow framework constraints. The code is production-ready, well-tested, and follows all architectural guidance provided in the story's dev notes.